//Disclaimer : Parts of the code were generated by AI

// ====================== DEBUG ======================
#define DEBUG 1

// ====================== LIBRARIES ======================
#include <WiFiS3.h>
#include <PubSubClient.h>
#include <LiquidCrystal.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <string.h>

// ====================== WIFI & UBIDOTS ======================
// NOTE: Replace placeholder values WiFi credentials and Ubidots Token
const char* WIFI_SSID     = "WIFI_SSID";
const char* WIFI_PASS     = "WIFI_PASS";
const char* UBIDOTS_TOKEN = "UBIDOTS_TOKEN";
const char* MQTT_SERVER   = "industrial.api.ubidots.com";
const int   MQTT_PORT     = 1883;
const char* DEVICE_LABEL  = "bioreactor";

WiFiClient wifiClient;
PubSubClient client(wifiClient);

// ====================== PINS ======================
const int turbidityPin    = A4; // Analog pin for Turbidity Sensor
const int waterlevelPin   = A5; // Analog pin for Water Level (Linear Potentiometer)
const int oneWireBus      = 2;  // Digital pin for OneWire Temperature Sensor

const int HeaterRelayPin  = 7;  // Digital pin for Heater Relay
const int EvacValvePin    = 5;  // Digital pin for Evacuation Solenoid Valve
const int FillValvePin    = 4;  // Digital pin for Refill Solenoid Valve
const int LightPin        = 3;  // Digital PWM pin for LED Control (via MOSFET)
const int AirpumpPin      = 6;  // Digital PWM pin for Air Pump Control (via MOSFET)

// ====================== LCD ======================
const int rs = 13, en = 12, d4 = 11, d5 = 10, d6 = 9, d7 = 8;
LiquidCrystal lcd(rs, en, d4, d5, d6, d7);

// ====================== TEMPERATURE SENSOR ======================
OneWire oneWire(oneWireBus);
DallasTemperature sensors(&oneWire);

// ====================== VARIABLES ======================
float temperature = 0.0;
int turbidity = 0; // Smoothed ADC reading
int waterlevel = 0; // Direct ADC reading

// Target parameters (updated via MQTT)
float temperaturetarget = 30.0;
int lightintensity = 0;     // 0–255 PWM value
int airpumpintensity = 0;   // 0–255 PWM value
int turbiditytarget = 500;  // Target ADC value for concentration control

bool heaterstate = false;

// System boundaries (ADC values from the linear potentiometer)
int lowwaterlevel = 200; // ADC value for low-level (draining limit)
int highwaterlevel = 900; // ADC value for high-level (filling limit)
const int HEATER_SAFETY_LEVEL = 100; // ADC value below which the heater MUST be off (dry-run prevention)

// ====================== SYSTEM STATE ======================
enum ReactorState { IDLE, DRAINING, VALVE_DELAY, FILLING, ERROR };
ReactorState reactorState = IDLE;
String errorMessage = "";
bool systemHealthy = true;

// ====================== TIMERS & DELAYS ======================
unsigned long lastTempUpdate = 0;
unsigned long lastMQTTSend = 0;
unsigned long lastLCDUpdate = 0;
unsigned long lastSensorRead = 0;
unsigned long stateStartTime = 0;
unsigned long valveChangeTime = 0;
unsigned long lastMQTTRetry = 0;

const unsigned long tempInterval = 5000;    // temperature reading (5 seconds)
const unsigned long mqttInterval = 15000;   // Ubidots send (15 seconds)
const unsigned long lcdInterval = 2000;     // display update (2 seconds)
const unsigned long sensorInterval = 1000;  // sensor reading (1 second)
const unsigned long stateTimeout = 120000;  // 2 minute timeout for state transitions (e.g., draining)
const unsigned long VALVE_DELAY_MS = 1000;  // 1 second delay between valve operations

// ====================== MQTT CONFIG ======================
#define MQTT_PAYLOAD_SIZE 256
char payload[MQTT_PAYLOAD_SIZE];
char topic[MQTT_PAYLOAD_SIZE];
int mqttRetryCount = 0;
const int MAX_MQTT_RETRIES = 3;

// ====================== SENSOR SMOOTHING ======================
const int SMOOTHING_READINGS = 5;
int turbidityReadings[SMOOTHING_READINGS];
int readIndex = 0;

// ====================== FUNCTION DECLARATIONS ======================
void initializeSensors();
int readSmoothedTurbidity();
int readWaterLevel();
void checkValveSafety();
void setLightPower(int power);
void setAirPumpPower(int power);
void reconnectMQTT();
void callback(char* topic, byte* payload, unsigned int length);
void controlReactor();
void controlTemperature();
void updateLCD();
void checkSystemHealth();
void setError(String message);
void handleErrorState();
void sendDataToUbidots();
void safeValveOperation(int valvePin, bool state);

// ====================== SENSOR FUNCTIONS ======================
// Fills the initial smoothing array and reads initial water level
void initializeSensors() {
  for (int i = 0; i < SMOOTHING_READINGS; i++) {
    turbidityReadings[i] = analogRead(turbidityPin);
    delay(10);
  }
  waterlevel = analogRead(waterlevelPin); // Initialize water level
}

// Implements a simple moving average filter for turbidity
int readSmoothedTurbidity() {
  for (int i = 0; i < SMOOTHING_READINGS - 1; i++) {
    turbidityReadings[i] = turbidityReadings[i + 1];
  }
  // Read the newest value and store it at the end
  turbidityReadings[SMOOTHING_READINGS - 1] = analogRead(turbidityPin);
  int total = 0;
  // Calculate the sum of all readings
  for (int i = 0; i < SMOOTHING_READINGS; i++) total += turbidityReadings[i];
  // Return the average
  return total / SMOOTHING_READINGS;
}

// Reads the water level directly from the linear potentiometer (ADC)
int readWaterLevel() {
  return analogRead(waterlevelPin);
}

// ====================== SAFETY FUNCTIONS ======================
// Prevents both fill and drain valves from being active simultaneously
void checkValveSafety() {
  bool evacState = digitalRead(EvacValvePin);
  bool fillState = digitalRead(FillValvePin);

  if (evacState && fillState) {
    // Force both valves off and enter error state
    digitalWrite(EvacValvePin, LOW);
    digitalWrite(FillValvePin, LOW);
    setError("SAFETY: Both valves active simultaneously");
    if (DEBUG) Serial.println("!!! SAFETY INTERLOCK: Both valves active. SHUT DOWN.");
  }
}

// Ensures a consistent time marker when changing valve state
void safeValveOperation(int valvePin, bool state) {
  digitalWrite(valvePin, state ? HIGH : LOW);
  valveChangeTime = millis();
  if (DEBUG) {
    Serial.print("Valve ");
    Serial.print(valvePin);
    Serial.print(state ? " OPENED" : " CLOSED");
    Serial.println();
  }
}

// ====================== OUTPUT CONTROL ======================
// Sets the LED light intensity using PWM
void setLightPower(int power) {
  power = constrain(power, 0, 255);
  analogWrite(LightPin, power);
  if (DEBUG) {
    Serial.print("Light intensity set to: ");
    Serial.println(power);
  }
}

// Sets the air pump speed using PWM
void setAirPumpPower(int power) {
  power = constrain(power, 0, 255);
  analogWrite(AirpumpPin, power);
  if (DEBUG) {
    Serial.print("Air pump intensity set to: ");
    Serial.println(power);
  }
}

// ====================== ERROR HANDLING ======================
// Sets system state to ERROR and shuts down critical actuators
void setError(String message) {
  reactorState = ERROR;
  errorMessage = message;
  systemHealthy = false;

  // Turn off all critical outputs immediately
  digitalWrite(HeaterRelayPin, LOW);
  digitalWrite(EvacValvePin, LOW);
  digitalWrite(FillValvePin, LOW);

  if (DEBUG) {
    Serial.print("ERROR: ");
    Serial.println(message);
  }
}

// Checks sensor values and network status for critical failures
void checkSystemHealth() {
  unsigned long now = millis();

  // 1. Temperature Sensor Check
  if (temperature == -127.0 || temperature < -50 || temperature > 100) {
    setError("Temperature sensor failure - reading out of range: " + String(temperature));
    return;
  }

  // 2. Heater Dry-Run Safety Check
  if (waterlevel < HEATER_SAFETY_LEVEL) {
    // This is a critical safety interlock, forces heater off regardless of control logic
    digitalWrite(HeaterRelayPin, LOW);
    heaterstate = false;
    setError("CRITICAL: Water level below safety minimum. Heater forced OFF.");
    return;
  }

  // 3. Water Level Sensor Check
  if (waterlevel < 0 || waterlevel > 1023) {
    setError("Water level sensor failure - reading out of range: " + String(waterlevel));
    return;
  }

  // 4. Turbidity Sensor Check
  if (turbidity < 0 || turbidity > 1023) {
    setError("Turbidity sensor failure - reading out of range: " + String(turbidity));
    return;
  }

  // 5. State Timeout Check (for long-running valve operations)
  if (reactorState != IDLE && reactorState != ERROR &&
      now - stateStartTime > stateTimeout) {
    safeValveOperation(EvacValvePin, false); // Fail-safe: close valves
    safeValveOperation(FillValvePin, false);
    setError("State timeout exceeded in state: " + String(reactorState));
    return;
  }

  // 6. WiFi Check
  if (WiFi.status() != WL_CONNECTED) {
    setError("WiFi connection lost");
    return;
  }

  // 7. Auto-recovery check (if system was unhealthy but error condition is gone)
  if (!systemHealthy && reactorState != ERROR) {
      systemHealthy = true;
      if (DEBUG) Serial.println("System health restored.");
  }
}

// Handles the display and recovery attempt when the system is in ERROR state
void handleErrorState() {
  static unsigned long lastErrorDisplay = 0;
  unsigned long now = millis();

  // Scroll error message on LCD every 2 seconds
  if (now - lastErrorDisplay >= 2000) {
    lastErrorDisplay = now;

    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("SYSTEM ERROR");
    lcd.setCursor(0, 1);

    static int scrollPos = 0;
    String displayMsg = errorMessage.substring(scrollPos);
    if (displayMsg.length() > 16) displayMsg = displayMsg.substring(0, 16);
    lcd.print(displayMsg);

    scrollPos++;
    if (scrollPos > errorMessage.length()) scrollPos = 0;

    if (DEBUG) {
      Serial.print("Error state - Message: ");
      Serial.println(errorMessage);
    }
  }

  // Attempt auto-recovery after 30 seconds if WiFi is stable
  if (now - stateStartTime > 30000 && WiFi.status() == WL_CONNECTED) {
    reactorState = IDLE;
    systemHealthy = true;
    if (DEBUG) Serial.println("Auto-recovery attempted - returning to IDLE state");
  }
}

// ====================== MQTT COMMUNICATION ======================
// Tries to reconnect to Ubidots MQTT broker
void reconnectMQTT() {
  if (mqttRetryCount >= MAX_MQTT_RETRIES) {
    setError("MQTT connection failed after max retries");
    return;
  }

  // Limit retry attempts frequency
  unsigned long now = millis();
  if (now - lastMQTTRetry < 5000) return;
  lastMQTTRetry = now;

  if (DEBUG) Serial.print("Attempting MQTT connection...");

  // Generate unique client ID for connection
  String clientId = "ArduinoBioreactor-" + String(random(0xffff), HEX);

  if (client.connect(clientId.c_str(), UBIDOTS_TOKEN, "")) {
    if (DEBUG) Serial.println("connected");
    mqttRetryCount = 0;

    // Subscribe to all target variables for remote control
    String topics[] = {
      "/v1.6/devices/" + String(DEVICE_LABEL) + "/airpumpintensity/lv",
      "/v1.6/devices/" + String(DEVICE_LABEL) + "/lightintensity/lv",
      "/v1.6/devices/" + String(DEVICE_LABEL) + "/turbiditytarget/lv",
      "/v1.6/devices/" + String(DEVICE_LABEL) + "/temperaturetarget/lv"
    };

    for (int i = 0; i < 4; i++) {
      if (client.subscribe(topics[i].c_str())) {
        if (DEBUG) {
          Serial.print("Subscribed to: ");
          Serial.println(topics[i]);
        }
      } else {
        if (DEBUG) {
          Serial.print("Failed to subscribe to: ");
          Serial.println(topics[i]);
        }
      }
    }
  } else {
    mqttRetryCount++;
    if (DEBUG) {
      Serial.print("failed, rc=");
      Serial.print(client.state());
      Serial.print(" Retry ");
      Serial.print(mqttRetryCount);
      Serial.println("/3");
    }
  }
}

// ====================== MQTT CALLBACK ======================
// Processes incoming messages from Ubidots (user control updates)
void callback(char* topic, byte* payload, unsigned int length) {
  // Convert payload to null-terminated string
  char msg[length + 1];
  for (unsigned int i = 0; i < length; i++) msg[i] = (char)payload[i];
  msg[length] = '\0';

  String topicStr = String(topic);

  if (DEBUG) {
    Serial.print("MQTT Message received: ");
    Serial.print(topicStr);
    Serial.print(" - ");
    Serial.println(msg);
  }

  // Parse payload and update appropriate variable/actuator
  if (topicStr.indexOf("airpumpintensity/lv") != -1) {
    airpumpintensity = atoi(msg);
    setAirPumpPower(airpumpintensity); // Direct control
  } else if (topicStr.indexOf("lightintensity/lv") != -1) {
    lightintensity = atoi(msg);
    setLightPower(lightintensity);     // Direct control
  } else if (topicStr.indexOf("turbiditytarget/lv") != -1) {
    turbiditytarget = atoi(msg);       // Setpoint update
  } else if (topicStr.indexOf("temperaturetarget/lv") != -1) {
    temperaturetarget = atof(msg);     // Setpoint update
  }
}

// ====================== SEND DATA ======================
// Compiles and sends all current sensor and state data to Ubidots
void sendDataToUbidots() {
  if (!client.connected()) {
    if (DEBUG) Serial.println("MQTT not connected, skipping data send");
    return;
  }

  // Construct topic for bulk publishing
  snprintf(topic, MQTT_PAYLOAD_SIZE, "/v1.6/devices/%s", DEVICE_LABEL);

  // Construct JSON payload with all key variables
  snprintf(payload, MQTT_PAYLOAD_SIZE,
           "{\"temperature\":%.2f,\"turbidity\":%d,\"waterlevel\":%d,\"heaterstate\":%d,\"system_healthy\":%d,\"temperaturetarget\":%.2f,\"turbiditytarget\":%d}",
           temperature, turbidity, waterlevel, heaterstate ? 1 : 0, systemHealthy ? 1 : 0, temperaturetarget, turbiditytarget);

  if (client.publish(topic, payload)) {
    if (DEBUG) {
      Serial.print("Data sent to Ubidots: ");
      Serial.println(payload);
    }
  } else {
    if (DEBUG) Serial.println("Failed to send data to Ubidots");
  }
}

// ====================== REACTOR CONTROL ======================
// State machine for draining and refilling the medium
void controlReactor() {
  unsigned long now = millis();

  switch (reactorState) {
    case IDLE:
      // Check if turbidity exceeds the user-defined threshold
      if (turbidity > turbiditytarget) {
        safeValveOperation(EvacValvePin, true);
        safeValveOperation(FillValvePin, false);
        reactorState = DRAINING;
        stateStartTime = now;
        if (DEBUG) Serial.println("→ DRAINING initiated");
      }
      break;

    case DRAINING:
      // Wait for VALVE_DELAY_MS after the valve opened to account for mechanical lag
      if (now - valveChangeTime < VALVE_DELAY_MS) break;

      // Stop draining when water level hits the low limit
      if (waterlevel <= lowwaterlevel) {
        safeValveOperation(EvacValvePin, false); // Close drain
        reactorState = VALVE_DELAY; // Move to delay state
        stateStartTime = now;
        if (DEBUG) Serial.println("→ VALVE_DELAY before filling");
      } else if (now - stateStartTime > stateTimeout) {
        // Safety timeout for draining
        safeValveOperation(EvacValvePin, false);
        setError("Timeout during DRAINING phase");
      }
      break;

    case VALVE_DELAY:
      // Wait for delay to ensure previous valve is fully shut
      if (now - stateStartTime >= VALVE_DELAY_MS) {
        safeValveOperation(FillValvePin, true); // Open fill valve
        reactorState = FILLING;
        stateStartTime = now;
        if (DEBUG) Serial.println("→ FILLING initiated");
      }
      break;

    case FILLING:
      // Wait for VALVE_DELAY_MS after the valve opened
      if (now - valveChangeTime < VALVE_DELAY_MS) break;

      // Stop filling when water level hits the high limit
      if (waterlevel >= highwaterlevel) {
        safeValveOperation(FillValvePin, false); // Close fill
        reactorState = IDLE;
        if (DEBUG) Serial.println("→ IDLE (filling complete)");
      } else if (now - stateStartTime > stateTimeout) {
        // Safety timeout for filling
        safeValveOperation(FillValvePin, false);
        setError("Timeout during FILLING phase");
      }
      break;

    case ERROR:
      // Stay in error state until manually reset or auto-recovery
      break;
  }
}

// ====================== TEMPERATURE CONTROL ======================
// Implements a simple hysteresis loop for temperature
void controlTemperature() {
  // Critical safety check: if water level is too low, force heater off
  if (!systemHealthy || waterlevel < HEATER_SAFETY_LEVEL) {
    digitalWrite(HeaterRelayPin, LOW);
    heaterstate = false;
    return;
  }

  // Hysteresis logic:
  // Turn ON if temperature is far below target (target - 1.0 C)
  if (temperature < temperaturetarget - 1.0) {
    digitalWrite(HeaterRelayPin, HIGH);
    heaterstate = true;
    if (DEBUG) Serial.println("Heater ON");
  // Turn OFF if temperature is slightly above target (target + 0.5 C)
  } else if (temperature > temperaturetarget + 0.5) {
    digitalWrite(HeaterRelayPin, LOW);
    heaterstate = false;
    if (DEBUG) Serial.println("Heater OFF");
  }
  // Otherwise, maintain current state (within the 1.5 C deadband)
}

// ====================== LCD UPDATE ======================
void updateLCD() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("T:");
  lcd.print(temperature, 1); // Display temperature with 1 decimal place
  lcd.print("C ");

  lcd.setCursor(8, 0);
  lcd.print("S:");
  // Display current reactor state
  switch (reactorState) {
    case IDLE: lcd.print("IDLE  "); break;
    case DRAINING: lcd.print("DRAIN "); break;
    case VALVE_DELAY: lcd.print("DELAY "); break;
    case FILLING: lcd.print("FILL  "); break;
    case ERROR: lcd.print("ERROR "); break;
  }

  lcd.setCursor(0, 1);
  lcd.print("Tu:");
  lcd.print(turbidity);
  lcd.print(" L:");
  lcd.print(waterlevel);

  // Status indicators
  if (heaterstate) lcd.print("*H"); // *H if heater is active
  if (!systemHealthy) lcd.print("!"); // ! if system is unhealthy/in error
}

// ====================== SETUP ======================
void setup() {
  Serial.begin(115200);
  if (DEBUG) Serial.println("Starting bioreactor setup...");

  // Initialize all actuator pins as outputs and ensure they are OFF/LOW
  pinMode(HeaterRelayPin, OUTPUT);
  pinMode(EvacValvePin, OUTPUT);
  pinMode(FillValvePin, OUTPUT);
  pinMode(LightPin, OUTPUT);
  pinMode(AirpumpPin, OUTPUT);

  digitalWrite(HeaterRelayPin, LOW);
  digitalWrite(EvacValvePin, LOW);
  digitalWrite(FillValvePin, LOW);
  analogWrite(LightPin, 0);
  analogWrite(AirpumpPin, 0);

  // Initialize LCD
  lcd.begin(16, 2);
  lcd.print("Bioreactor Init");
  delay(1000);

  // Initialize Sensors
  sensors.begin();
  initializeSensors();

  // Connect to WiFi
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  if (DEBUG) Serial.println("Connecting to WiFi...");

  int wifiRetries = 0;
  while (WiFi.status() != WL_CONNECTED && wifiRetries < 10) {
    delay(1000);
    wifiRetries++;
    if (DEBUG) {
      Serial.print(".");
      if (wifiRetries % 5 == 0) Serial.println();
    }
  }

  if (WiFi.status() == WL_CONNECTED) {
    if (DEBUG) {
      Serial.println("\nConnected to WiFi");
      Serial.print("IP address: ");
      Serial.println(WiFi.localIP());
    }
  } else {
    // If WiFi fails, enter error state
    setError("WiFi connection failed (Setup)");
  }

  // Configure MQTT client
  client.setServer(MQTT_SERVER, MQTT_PORT);
  client.setCallback(callback);
  client.setBufferSize(MQTT_PAYLOAD_SIZE);

  if (DEBUG) Serial.println("Setup complete");
}

// ====================== MAIN LOOP ======================
void loop() {
  unsigned long now = millis();

  // 1. MQTT Connection/Loop
  if (!client.connected() && systemHealthy) reconnectMQTT();
  if (systemHealthy) client.loop(); // Must call client.loop() regularly to maintain connection

  // 2. Critical Safety Checks (Always run)
  checkValveSafety();
  checkSystemHealth();

  // If in error state, handle display and recovery attempts, then stop further control logic
  if (reactorState == ERROR) {
    handleErrorState();
    return;
  }

  // 3. Temperature Reading and Control
  if (now - lastTempUpdate >= tempInterval) {
    lastTempUpdate = now;
    sensors.requestTemperatures();
    temperature = sensors.getTempCByIndex(0);
    controlTemperature(); // Hysteresis control
  }

  // 4. Sensor Reading and Concentration Control
  if (now - lastSensorRead >= sensorInterval) {
    lastSensorRead = now;
    turbidity = readSmoothedTurbidity();
    waterlevel = readWaterLevel();
    controlReactor(); // State machine for drain/fill cycles
  }

  // 5. Data Transmission
  if (now - lastMQTTSend >= mqttInterval) {
    lastMQTTSend = now;
    sendDataToUbidots();
  }

  // 6. LCD Display Update
  if (now - lastLCDUpdate >= lcdInterval) {
    lastLCDUpdate = now;
    updateLCD();
  }
}

